diff -ur a/java/TJBench.java b/java/TJBench.java
--- a/java/TJBench.java	2025-01-02 15:12:55.736180182 +0000
+++ b/java/TJBench.java	2025-01-02 15:11:35.372235524 +0000
@@ -89,6 +89,8 @@
     int rindex = TJ.getRedOffset(pf);
     int gindex = TJ.getGreenOffset(pf);
     int bindex = TJ.getBlueOffset(pf);
+    if ((long)w[0] * (long)h[0] * (long)ps > (long)Integer.MAX_VALUE)
+      throw new Exception("Image is too large");
     byte[] dstBuf = new byte[w[0] * h[0] * ps];
     int pixels = w[0] * h[0], dstPtr = 0, rgbPtr = 0;
     while (pixels-- > 0) {
@@ -144,8 +146,11 @@
     tjd = new TJDecompressor();
   
     int bufSize = (yuv == YUVDECODE ? yuvSize : pitch * scaledh);
-    if (dstBuf == null)
+    if (dstBuf == null) {
+      if ((long)pitch * (long)scaledh > (long)Integer.MAX_VALUE)
+        throw new Exception("Image is too large");
       dstBuf = new byte[bufSize];
+    }
 
     /* Set the destination buffer to gray so we know whether the decompressor
        attempted to write to it */
@@ -319,6 +324,8 @@
       return;
     }
  
+    if ((long)pitch * (long)h > (long)Integer.MAX_VALUE)
+      throw new Exception("Image is too large");
     tmpBuf = new byte[pitch * h];
 
     if (quiet == 0)
@@ -432,6 +439,8 @@
     int ps = TJ.getPixelSize(pf), tile;
   
     FileInputStream fis = new FileInputStream(fileName);
+    if (fis.getChannel().size() > (long)Integer.MAX_VALUE)
+      throw new Exception("Image is too large");
     int srcSize = (int)fis.getChannel().size();
     srcBuf = new byte[srcSize];
     fis.read(srcBuf, 0, srcSize);
diff -ur a/tjbench.c b/tjbench.c
--- a/tjbench.c	2025-01-02 15:12:55.737180169 +0000
+++ b/tjbench.c	2025-01-02 15:11:35.372235524 +0000
@@ -31,6 +31,7 @@
 #include <string.h>
 #include <math.h>
 #include <errno.h>
+#include <limits.h>
 #include <cdjpeg.h>
 #include "./bmp.h"
 #include "./tjutil.h"
@@ -94,13 +95,16 @@
 	int row, col, i, dstbufalloc=0, retval=0;
 	double start, elapsed;
 	int ps=tjPixelSize[pf];
-	int yuvsize=tjBufSizeYUV(w, h, subsamp), bufsize;
+	unsigned long yuvsize=tjBufSizeYUV(w, h, subsamp), bufsize;
 	int scaledw=(yuv==YUVDECODE)? w : TJSCALED(w, sf);
 	int scaledh=(yuv==YUVDECODE)? h : TJSCALED(h, sf);
 	int pitch=scaledw*ps;
 	int ntilesw=(w+tilew-1)/tilew, ntilesh=(h+tileh-1)/tileh;
 	unsigned char *dstptr, *dstptr2;
 
+    if (yuvsize == (unsigned long)-1)
+        _throwtj("allocating YUV buffer");
+
 	if(jpegqual>0)
 	{
 		snprintf(qualstr, 6, "_Q%d", jpegqual);
@@ -110,9 +114,12 @@
 	if((handle=tjInitDecompress())==NULL)
 		_throwtj("executing tjInitDecompress()");
 
-	bufsize=(yuv==YUVDECODE? yuvsize:pitch*scaledh);
+	bufsize=(yuv==YUVDECODE? yuvsize:(size_t)pitch*scaledh);
 	if(dstbuf==NULL)
 	{
+        if ((unsigned long long)pitch * (unsigned long long)scaledh >
+            (unsigned long long)((size_t)-1))
+            _throwunix("allocating destination buffer - Image is too large");
 		if((dstbuf=(unsigned char *)malloc(bufsize)) == NULL)
 			_throwunix("allocating image buffer");
 		dstbufalloc=1;
@@ -140,7 +147,7 @@
 			if(tjDecompressToYUV(handle, jpegbuf[0], jpegsize[0], dstbuf, flags)==-1)
 			_throwtj("executing tjDecompressToYUV()");
 		}
-		else for(row=0, dstptr=dstbuf; row<ntilesh; row++, dstptr+=pitch*tileh)
+		else for(row=0, dstptr=dstbuf; row<ntilesh; row++, dstptr+=(size_t)pitch*tileh)
 		{
 			for(col=0, dstptr2=dstptr; col<ntilesw; col++, tile++, dstptr2+=ps*tilew)
 			{
@@ -199,14 +206,14 @@
 			if(!quiet) printf("Compression error written to %s.\n", tempstr);
 			if(subsamp==TJ_GRAYSCALE)
 			{
-				int index, index2;
+				unsigned long index, index2;
 				for(row=0, index=0; row<h; row++, index+=pitch)
 				{
 					for(col=0, index2=index; col<w; col++, index2+=ps)
 					{
-						int rindex=index2+tjRedOffset[pf];
-						int gindex=index2+tjGreenOffset[pf];
-						int bindex=index2+tjBlueOffset[pf];
+						unsigned long rindex=index2+tjRedOffset[pf];
+						unsigned long gindex=index2+tjGreenOffset[pf];
+						unsigned long bindex=index2+tjBlueOffset[pf];
 						int y=(int)((double)srcbuf[rindex]*0.299
 							+ (double)srcbuf[gindex]*0.587
 							+ (double)srcbuf[bindex]*0.114 + 0.5);
@@ -216,7 +223,7 @@
 						dstbuf[bindex]=abs(dstbuf[bindex]-y);
 					}
 				}
-			}		
+			}
 			else
 			{
 				for(row=0; row<h; row++)
@@ -246,9 +253,12 @@
 	unsigned char *dstbuf=NULL;
 	double start, elapsed;
 	int i, retval=0, ps=tjPixelSize[pf];
-	int yuvsize=0;
+	unsigned long yuvsize=0;
 
 	yuvsize=tjBufSizeYUV(w, h, subsamp);
+    if (yuvsize == (unsigned long)-1)
+        _throwtj("allocating YUV buffer");
+
 	if((dstbuf=(unsigned char *)malloc(yuvsize)) == NULL)
 		_throwunix("allocating image buffer");
 
@@ -290,7 +300,7 @@
 	{
 		printf("\n%s size: %d x %d\n", "Image", w, h);
 		printf("C--> Frame rate:           %f fps\n", (double)i/elapsed);
-		printf("     Output image size:    %d bytes\n", yuvsize);
+		printf("     Output image size:    %lu bytes\n", yuvsize);
 		printf("     Compression ratio:    %f:1\n",
 			(double)(w*h*ps)/(double)yuvsize);
 		printf("     Source throughput:    %f Megapixels/sec\n",
@@ -325,9 +335,13 @@
 	unsigned long *jpegsize=NULL;
 	int ps=tjPixelSize[pf], ntilesw=1, ntilesh=1, pitch=w*ps;
 
+    if ((unsigned long long)pitch * (unsigned long long)h >
+        (unsigned long long)((size_t)-1))
+        _throwunix("allocating temporary image buffer - Image is too large");
+
 	if(yuv==YUVENCODE) {dotestyuv(srcbuf, w, h, subsamp, filename);  return;}
 
-	if((tmpbuf=(unsigned char *)malloc(pitch*h)) == NULL)
+	if((tmpbuf=(unsigned char *)malloc((size_t)pitch*h)) == NULL)
 		_throwunix("allocating temporary image buffer");
 
 	if(!quiet)
@@ -352,6 +366,8 @@
 		if((flags&TJFLAG_NOREALLOC)!=0)
 			for(i=0; i<ntilesw*ntilesh; i++)
 			{
+                if (tjBufSize(tilew, tileh, subsamp) > (unsigned long)INT_MAX)
+                    _throwunix("getting buffer size - Image is too large");
 				if((jpegbuf[i]=(unsigned char *)malloc(tjBufSize(tilew, tileh,
 					subsamp)))==NULL)
 					_throwunix("allocating JPEG tiles");
@@ -523,6 +539,8 @@
 		if((flags&TJFLAG_NOREALLOC)!=0)
 			for(i=0; i<ntilesw*ntilesh; i++)
 			{
+                if (tjBufSize(tilew, tileh, subsamp) > (unsigned long)INT_MAX)
+                    _throwunix("getting buffer size - Image is too large");
 				if((jpegbuf[i]=(unsigned char *)malloc(tjBufSize(tilew, tileh,
 					subsamp)))==NULL)
 					_throwunix("allocating JPEG tiles");
@@ -582,10 +600,13 @@
 					t[tile].customFilter=customFilter;
 					if(t[tile].options&TJXOPT_NOOUTPUT && jpegbuf[tile])
 					{
+                        if(jpegbuf[tile])
+                        {
 						free(jpegbuf[tile]);  jpegbuf[tile]=NULL;
 					}
 				}
 			}
+			}
 
 			start=gettime();
 			if(tjTransform(handle, srcbuf, srcsize, _ntilesw*_ntilesh, jpegbuf,
@@ -637,8 +658,11 @@
 
 		for(i=0; i<ntilesw*ntilesh; i++)
 		{
+            if(jpegbuf[tile])
+            {
 			free(jpegbuf[i]);  jpegbuf[i]=NULL;
 		}
+		}
 		free(jpegbuf);  jpegbuf=NULL;
 		if(jpegsize) {free(jpegsize);  jpegsize=NULL;}
 
diff -ur a/tjunittest.c b/tjunittest.c
--- a/tjunittest.c	2025-01-02 15:12:55.738180156 +0000
+++ b/tjunittest.c	2025-01-02 16:12:50.126115709 +0000
@@ -528,6 +529,37 @@
 }
 
 
+#if SIZEOF_SIZE_T == 8
+#define CHECKSIZE(function) { \
+  if ((unsigned long long)size < (unsigned long long)0xFFFFFFFF) \
+    _throw(#function " overflow"); \
+}
+#else
+#define CHECKSIZE(function) { \
+  if (size != (unsigned long)(-1) || \
+      !strcmp(tjGetErrorStr(), "No error")) \
+    _throw(#function " overflow"); \
+}
+#endif
+static void overflowTest(void)
+{
+  /* Ensure that the various buffer size functions don't overflow */
+  unsigned long size;
+  size = tjBufSize(26755, 26755, TJSAMP_444);
+  CHECKSIZE(tjBufSize());
+  size = TJBUFSIZE(26755, 26755);
+  CHECKSIZE(TJBUFSIZE());
+  size = tjBufSizeYUV(37838, 37838, TJSAMP_444);
+  CHECKSIZE(tjBufSizeYUV());
+  size = TJBUFSIZEYUV(37838, 37838, TJSAMP_444);
+  CHECKSIZE(TJBUFSIZEYUV());
+  size = tjBufSizeYUV(37838, 37838, TJSAMP_444);
+  CHECKSIZE(tjBufSizeYUV());
+bailout:
+  return;
+}
+
+
 void bufSizeTest(void)
 {
 	int w, h, i, subsamp;
@@ -617,6 +649,7 @@
 	}
 	if(alloc) printf("Testing automatic buffer allocation\n");
 	if(doyuv) {yuv=YUVENCODE;  alloc=0;}
+    overflowTest();
 	doTest(35, 39, _3byteFormats, 2, TJSAMP_444, "test");
 	doTest(39, 41, _4byteFormats, 4, TJSAMP_444, "test");
 	doTest(41, 35, _3byteFormats, 2, TJSAMP_422, "test");
diff -ur a/turbojpeg.c b/turbojpeg.c
--- a/turbojpeg.c	2025-01-02 15:12:55.739180142 +0000
+++ b/turbojpeg.c	2025-01-02 16:13:54.337300728 +0000
@@ -30,6 +30,7 @@
    libjpeg-turbo */
 
 #include <stdio.h>
+#include <stdint.h>
 #include <stdlib.h>
 #include <jinclude.h>
 #define JPEG_INTERNALS
@@ -515,7 +516,7 @@
 DLLEXPORT unsigned long DLLCALL tjBufSize(int width, int height,
 	int jpegSubsamp)
 {
-	unsigned long retval=0;  int mcuw, mcuh, chromasf;
+	unsigned long long retval=0;  int mcuw, mcuh, chromasf;
 	if(width<1 || height<1 || jpegSubsamp<0 || jpegSubsamp>=NUMSUBOPT)
 		_throw("tjBufSize(): Invalid argument");
 
@@ -525,43 +526,49 @@
 	mcuw=tjMCUWidth[jpegSubsamp];
 	mcuh=tjMCUHeight[jpegSubsamp];
 	chromasf=jpegSubsamp==TJSAMP_GRAY? 0: 4*64/(mcuw*mcuh);
-	retval=PAD(width, mcuw) * PAD(height, mcuh) * (2 + chromasf) + 2048;
+	retval=PAD(width, mcuw) * PAD(height, mcuh) * (2ULL + chromasf) + 2048ULL;
+    if (retval > (unsigned long long)((uint32_t)-1))
+        _throw("tjBufSize(): Image is too large");
 
 	bailout:
-	return retval;
+	return (unsigned long)retval;
 }
 
 
 DLLEXPORT unsigned long DLLCALL TJBUFSIZE(int width, int height)
 {
-	unsigned long retval=0;
+	unsigned long long retval=0;
 	if(width<1 || height<1)
 		_throw("TJBUFSIZE(): Invalid argument");
 
 	// This allows for rare corner cases in which a JPEG image can actually be
 	// larger than the uncompressed input (we wouldn't mention it if it hadn't
 	// happened before.)
-	retval=PAD(width, 16) * PAD(height, 16) * 6 + 2048;
+	retval=PAD(width, 16) * PAD(height, 16) * 6ULL + 2048ULL;
+    if (retval > (unsigned long long)((uint32_t)-1))
+        _throw("TJBUFSIZE(): Image is too large");
 
 	bailout:
-	return retval;
+	return (unsigned long)retval;
 }
 
 
 DLLEXPORT unsigned long DLLCALL tjBufSizeYUV(int width, int height,
 	int subsamp)
 {
-	unsigned long retval=0;
+	unsigned long long retval=0;
 	int pw, ph, cw, ch;
 	if(width<1 || height<1 || subsamp<0 || subsamp>=NUMSUBOPT)
 		_throw("tjBufSizeYUV(): Invalid argument");
 	pw=PAD(width, tjMCUWidth[subsamp]/8);
 	ph=PAD(height, tjMCUHeight[subsamp]/8);
 	cw=pw*8/tjMCUWidth[subsamp];  ch=ph*8/tjMCUHeight[subsamp];
-	retval=PAD(pw, 4)*ph + (subsamp==TJSAMP_GRAY? 0:PAD(cw, 4)*ch*2);
+	retval=PAD(pw, 4)*ph + (subsamp==TJSAMP_GRAY? 0ULL:PAD(cw, 4)*ch*2ULL);
+    if (retval > (unsigned long long)((uint32_t)-1))
+        _throw("tjBufSizeYUV(): Image is too large");
 
 	bailout:
-	return retval;
+	return (unsigned long)retval;
 }
 
 
@@ -629,8 +636,8 @@
 		_throw("tjCompress2(): Memory allocation failure");
 	for(i=0; i<height; i++)
 	{
-		if(flags&TJFLAG_BOTTOMUP) row_pointer[i]=&srcBuf[(height-i-1)*pitch];
-		else row_pointer[i]=&srcBuf[i*pitch];
+		if(flags&TJFLAG_BOTTOMUP) row_pointer[i]=&srcBuf[(height-i-1)*(size_t)pitch];
+		else row_pointer[i]=&srcBuf[i*(size_t)pitch];
 	}
 	while(cinfo->next_scanline<cinfo->image_height)
 	{
@@ -739,8 +746,8 @@
 		_throw("tjEncodeYUV2(): Memory allocation failure");
 	for(i=0; i<height; i++)
 	{
-		if(flags&TJFLAG_BOTTOMUP) row_pointer[i]=&srcBuf[(height-i-1)*pitch];
-		else row_pointer[i]=&srcBuf[i*pitch];
+		if(flags&TJFLAG_BOTTOMUP) row_pointer[i]=&srcBuf[(height-i-1)*(size_t)pitch];
+		else row_pointer[i]=&srcBuf[i*(size_t)pitch];
 	}
 	if(height<ph)
 		for(i=height; i<ph; i++) row_pointer[i]=row_pointer[height-1];
@@ -1004,8 +1011,8 @@
 	for(i=0; i<(int)dinfo->output_height; i++)
 	{
 		if(flags&TJFLAG_BOTTOMUP)
-			row_pointer[i]=&dstBuf[(dinfo->output_height-i-1)*pitch];
-		else row_pointer[i]=&dstBuf[i*pitch];
+			row_pointer[i]=&dstBuf[(dinfo->output_height-i-1)*(size_t)pitch];
+		else row_pointer[i]=&dstBuf[i*(size_t)pitch];
 	}
 	while(dinfo->output_scanline<dinfo->output_height)
 	{
